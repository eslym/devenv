__bash_prompt() {
  local exit_code=$?
  local userpart
  if [[ -n ${GITHUB_USER:-} ]]; then
    userpart="\[\033[0;32m\]@${GITHUB_USER} "
  else
    userpart="\[\033[0;32m\]\u"
  fi
  local arrow="\[\033[0m\]➜"
  [[ $exit_code -ne 0 ]] && arrow="\[\033[1;31m\]➜"

  local gitbranch=$(
    if [[ $(git config --get devcontainers-theme.hide-status 2>/dev/null) != 1 ]] &&
       [[ $(git config --get codespaces-theme.hide-status 2>/dev/null) != 1 ]]; then
      b=$(git --no-optional-locks symbolic-ref --short HEAD 2>/dev/null \
          || git --no-optional-locks rev-parse --short HEAD 2>/dev/null)
      if [[ -n $b ]]; then
        printf "\[\033[0;36m\](\[\033[1;31m\]%s" "$b"
        if [[ $(git config --get devcontainers-theme.show-dirty 2>/dev/null) == 1 ]] &&
           git --no-optional-locks ls-files --error-unmatch -m --directory --no-empty-directory -o --exclude-standard ":/*" >/dev/null 2>&1; then
          printf " \[\033[1;33m\]✗"
        fi
        printf "\[\033[0;36m\]) "
      fi
    fi
  )

  PS1="${userpart} ${arrow} \[\033[1;34m\]\w ${gitbranch}\[\033[0m\]\$ "
}

# Recompute prompt each time instead of unsetting the function
PROMPT_COMMAND="__bash_prompt${PROMPT_COMMAND:+;$PROMPT_COMMAND}"
export PROMPT_DIRTRIM=4


# Check if the terminal is xterm
if [[ "$TERM" == "xterm" ]]; then
    # Function to set the terminal title to the current command
    preexec() {
        local cmd="${BASH_COMMAND}"
        echo -ne "\033]0;${USER}@${HOSTNAME}: ${cmd}\007"
    }

    # Function to reset the terminal title to the shell type after the command is executed
    precmd() {
        echo -ne "\033]0;${USER}@${HOSTNAME}: ${SHELL}\007"
    }

    # Trap DEBUG signal to call preexec before each command
    trap 'preexec' DEBUG

    # Append to PROMPT_COMMAND to call precmd before displaying the prompt
    PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND; }precmd"
fi
